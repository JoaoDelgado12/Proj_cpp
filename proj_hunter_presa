#include <iostream>
#include <random> 
#include <string> // para mudar o tipo do indice para string no nome
#include <cstring> // para facilitar copiar matriz

using namespace std;

const int TAM_MAP = 30;
char map[TAM_MAP][TAM_MAP];

//função para gerar numero aleatorio inteiro
int num_int_rand(int min, int max) {

    // Inicializar o gerador de números aleatórios
    random_device rd;  // Dispositivo aleatório (fonte de entropia)
    mt19937 gen(rd()); // Motor de geração (Mersenne Twister)

    //  Criar uma distribuição uniforme no intervalo [min, max]
    uniform_int_distribution<int> distrib(min, max);

    //  Gerar o número aleatório
    return distrib(gen);
}

void create_map() {
    for(int i = 0; i < TAM_MAP; i++) {
        for(int j = 0; j < TAM_MAP; j++) {
            map[i][j] = '.';
        }
    }
}

void show_map() {
    for(int i = 0; i < TAM_MAP; i++) {
        for(int j = 0; j < TAM_MAP; j++) {
            cout << map[i][j];
        }
        cout << "\n";
    }
}

class animal {
	protected:
   		bool life = true;
    	int fome;
    	
    	int hood[8][2]; // vizinhaça da coordenada do animal
    	public:
    		int position[2]; // coordenada do animal
    		animal(){
    		//para nascimento
    		bool test = true;
    		while(test) {
        	position[0] = num_int_rand(0, TAM_MAP - 1);
        	position[1] = num_int_rand(0, TAM_MAP - 1);
        
        	if(map[position[0]][position[1]] == '.') {
            	test = false;
        		}
			}					
		}
			void up_hood();
};


void animal::up_hood(){
	if(position[0] == 0){
		if(position[1] == 0){
			int temp_hood[8][2] = {{0, TAM_MAP-1}, {0, 1}, 
			{1, TAM_MAP-1}, {1, 0}, {1, 1}, 
			{TAM_MAP-1, 0}, {TAM_MAP-1, TAM_MAP-1}, {TAM_MAP-1, 1} };
			memcpy(hood, temp_hood, sizeof(hood));
		}else if(position[1] == TAM_MAP - 1){
			int temp_hood[8][2] = {{0, TAM_MAP-2}, {0, 1}, 
			{TAM_MAP-1, TAM_MAP-1}, {TAM_MAP-1, 0}, {TAM_MAP-1, TAM_MAP-2}, 
			{1, TAM_MAP-2}, {1, TAM_MAP-1}, {1, 0} };	
			memcpy(hood, temp_hood, sizeof(hood));
		}else{
			int temp_hood[8][2] = {{position[0], position[1]-1}, {position[0], position[1]+1}, 
			{TAM_MAP-1, position[1]-1}, {TAM_MAP-1, position[1]}, {TAM_MAP-1, position[1]+1}, 
			{position[0]+1, position[1]-1}, {position[0]+1, position[1]}, {position[0]+1, position[1]+1}};
			memcpy(hood, temp_hood, sizeof(hood));
		}
		
	}else if(position[0] == TAM_MAP - 1){
		if(position[1] == 0){
			int temp_hood[8][2] = {{TAM_MAP-1, TAM_MAP-1}, {TAM_MAP-1, 1}, 
			{0, 0}, {0, TAM_MAP-1}, {0, 1}, 
			{TAM_MAP-2, 0}, {TAM_MAP-2, TAM_MAP-1}, {TAM_MAP-2, 1} };
			memcpy(hood, temp_hood, sizeof(hood));
		}else if(position[1] == TAM_MAP - 1){
			int temp_hood[8][2] = {{TAM_MAP-1, TAM_MAP-2}, {TAM_MAP-1, 0}, 
			{TAM_MAP-2, TAM_MAP-1}, {TAM_MAP-2, TAM_MAP-2}, {TAM_MAP-2, 0}, 
			{0, TAM_MAP-1}, {0, 0}, {0, TAM_MAP-2} };
			memcpy(hood, temp_hood, sizeof(hood));
		}else{
			int temp_hood[8][2] = {{position[0], position[1]-1}, {position[0], position[1]+1}, 
			{position[0]-1, position[1]-1}, {position[0]-1, position[1]}, {position[0]-1, position[1]+1}, 
			{0, position[1]-1}, {0, position[1]}, {0, position[1]+1}};
			memcpy(hood, temp_hood, sizeof(hood));
		}		
	}else{
		int temp_hood[8][2] = {{position[0], position[1]-1}, {position[0], position[1]+1}, 
			{position[0]-1, position[1]-1}, {position[0]-1, position[1]}, {position[0]-1, position[1]+1}, 
			{position[0]+1, position[1]-1}, {position[0]+1, position[1]}, {position[0]+1, position[1]+1}};	
		memcpy(hood, temp_hood, sizeof(hood));	
	}	
	
}


class hunter : public animal {
    public:
    hunter(){
    	fome = 3;
    	map[position[0]][position[1]] = 'H';
    	
	}	
	void walk_hunter();
	
};

void hunter::walk_hunter(){
	int around_hunter = 0;
	int coord_presa[8];
	for(int i=0; i<8; i++){
		if(map[hood[i][0]][hood[i][1]] == 'P'){
			coord_presa[around_hunter] = i;
			around_hunter++;
		} 
	}
	
	if(around_hunter == 0){
		int new_indice = num_int_rand(0,7);
		map[position[0]][position[1]] = '.';//a posição que ele estava, agora está vazia
		position[0] = hood[new_indice][0];
		position[1] = hood[new_indice][1];
		map[position[0]][position[1]] = 'H';
	}else{
		int new_indice = coord_presa[num_int_rand(0,around_hunter-1)];
		map[position[0]][position[1]] = '.';//a posição que ele estava, agora está vazia
		position[0] = hood[new_indice][0];
		position[1] = hood[new_indice][1];
		map[position[0]][position[1]] = 'H';
	}
}


class presa : public animal {
public:
    presa(){
    fome = 3;
    map[position[0]][position[1]] = 'P';
	}
};



int main() {
    create_map();
    int quant_hunter = 0, quant_presa = 0;
    
    // Criação do vetor de hunters
    cout << "Quantos hunters ? \n";
    cin >> quant_hunter;
    hunter* hunters = new hunter[quant_hunter];
    
    // Criação do vetor de presas
    cout << "Quantos presas ? \n";
    cin >> quant_presa;
    presa* presas = new presa[quant_presa];
    
    cout << hunters[0].position[0] << " " <<  hunters[0].position[1]; 
    
    for(int i=0; i<1000; i++){
    	show_map();
    	hunters[0].up_hood();
    	hunters[0].walk_hunter();
    	system("cls");
    }
    
    
    // Liberação de memória ao fim do codigo
    delete[] hunters;
    delete[] presas;
    
    return 0;
}
